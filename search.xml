<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Storm 开箱</title>
      <link href="/2018/11/10/Storm/"/>
      <url>/2018/11/10/Storm/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是-Storm"><a href="#1-什么是-Storm" class="headerlink" title="1.什么是 Storm"></a>1.什么是 Storm</h3><p> Storm 是一个<strong>分布式</strong>的，<strong>可靠</strong>的，<strong>容错</strong>的<strong>数据流处理</strong>系统。</p><p><img src="https://s1.ax1x.com/2018/05/10/C0prnK.md.png" alt="storm-flow.png"></p><p>Storm 应用是由 Spout （上图水龙头） 和 Bolt （上图水滴） 构建成的Topology在Storm环境中运行,其中 Spout 负责接收或获取源数据并发送给 Bolt 进行业务处理， Bolt 处理完数据后，发送给下个 Bolt 或结束任务。</p><p>Storm 支持两种运行模式:<br><strong>本地模式</strong> -此模式用于开发，测试和调试，因为它是查看所有拓扑组件协同工作的最简单方法。在这种模式下，我们可以调整参数，使我们能够看到我们的拓扑如何在不同的 Storm 配置环境中运行。在本地模式下， storm 拓扑在本地机器上在单个 JVM 中运行。<br><strong>远程模式/生产模式</strong> -在这种模式下，我们将拓扑提交到工作 Storm 集群，该集群由许多进程组成，通常运行在不同的机器上。如在 Storm 的工作流中所讨论的，工作集群将无限地运行，直到它被关闭。</p><p>若无特殊说明，本文所有的场景和代码都是以<strong>本地模式</strong>运行</p><a id="more"></a><hr><h3 id="2-Hello-World-WordCountTopology"><a href="#2-Hello-World-WordCountTopology" class="headerlink" title="2. Hello World(WordCountTopology)"></a>2. Hello World(WordCountTopology)</h3><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p>需求，统计句子中，任意单词出现的数量。</p><p>单词计数器例子流程。<br>1.SentenceSpout 发射出句子元组（tuple）。<br>2.SplitSentenceBolt 接收到句子，将句子拆分成单词，并将单词发射出去。<br>3.WordCountBolt 接收到单词，分别记录单词出现的数量，将统计结果发射出去。<br>4.ReportBolt 接收并存储计结果，待程序结束运行后打印统计结果。</p><p>流程：获取句子 -&gt; 拆分成单词 -&gt; 统计单词 -&gt; 输出报表</p><div id="flowchart-0" class="flow-chart"></div><h4 id="2-2-Getting-Started"><a href="#2-2-Getting-Started" class="headerlink" title="2.2 Getting-Started"></a>2.2 Getting-Started</h4><p>在任意IDE中创建一个新的 Maven 项目，并在 pom.xml 添加 Apache Storm 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.storm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>storm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-编写-SentenceSpout-java"><a href="#2-3-编写-SentenceSpout-java" class="headerlink" title="2.3 编写 SentenceSpout.java"></a>2.3 编写 SentenceSpout.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> spouts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.spout.SpoutOutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichSpout;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Values;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.utils.Utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向后端发射tuple数据流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> soul</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentenceSpout</span> <span class="keyword">extends</span> <span class="title">BaseRichSpout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BaseRichSpout是ISpout接口和IComponent接口的简单实现，接口对用不到的方法提供了默认的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6768845742899211592L</span>;</span><br><span class="line"><span class="keyword">private</span> SpoutOutputCollector collector;</span><br><span class="line">    <span class="keyword">private</span> String[] sentences = &#123;</span><br><span class="line">            <span class="string">"my name is soul"</span>,</span><br><span class="line">            <span class="string">"im a boy"</span>,</span><br><span class="line">            <span class="string">"i have a dog"</span>,</span><br><span class="line">            <span class="string">"my dog has fleas"</span>,</span><br><span class="line">            <span class="string">"my girl friend is beautiful"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * open()方法中是ISpout接口中定义，在Spout组件初始化时被调用。</span></span><br><span class="line"><span class="comment">     * open()接受三个参数:一个包含Storm配置的Map,一个TopologyContext对象，提供了topology中组件的信息,SpoutOutputCollector对象提供发射tuple的方法。</span></span><br><span class="line"><span class="comment">     * 在这个例子中,我们不需要执行初始化,只是简单的存储在一个SpoutOutputCollector实例变量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * nextTuple()方法是任何Spout实现的核心。</span></span><br><span class="line"><span class="comment">     * Storm调用这个方法，向输出的collector发出tuple。</span></span><br><span class="line"><span class="comment">     * 在这里,我们只是发出当前索引的句子，并增加该索引准备发射下一个句子。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.collector.emit(<span class="keyword">new</span> Values(sentences[index]));</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (index&gt;=sentences.length) &#123;</span><br><span class="line">            index=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Utils.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * declareOutputFields是在IComponent接口中定义的，所有Storm的组件（spout和bolt）都必须实现这个接口</span></span><br><span class="line"><span class="comment">     * 用于告诉Storm流组件将会发出那些数据流，每个流的tuple将包含的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"sentence"</span>));<span class="comment">//告诉组件发出数据流包含sentence字段</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-编写-SplitSentenceBolt-java"><a href="#2-4-编写-SplitSentenceBolt-java" class="headerlink" title="2.4 编写 SplitSentenceBolt.java"></a>2.4 编写 SplitSentenceBolt.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bolts;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.OutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Tuple;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅sentence spout发射的tuple流，实现分割单词</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitSentenceBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BaseRichBolt是IComponent和IBolt接口的实现</span></span><br><span class="line">    <span class="comment">//继承这个类，就不用去实现本例不关心的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * prepare()方法类似于ISpout 的open()方法。</span></span><br><span class="line"><span class="comment">     * 这个方法在blot初始化时调用，可以用来准备bolt用到的资源,比如数据库连接。</span></span><br><span class="line"><span class="comment">     * 本例子和SentenceSpout类一样,SplitSentenceBolt类不需要太多额外的初始化,</span></span><br><span class="line"><span class="comment">     * 所以prepare()方法只保存OutputCollector对象的引用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">this</span>.collector=collector;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SplitSentenceBolt核心功能是在类IBolt定义execute()方法，这个方法是IBolt接口中定义。</span></span><br><span class="line"><span class="comment">     * 每次Bolt从流接收一个订阅的tuple，都会调用这个方法。</span></span><br><span class="line"><span class="comment">     * 本例中,收到的元组中查找“sentence”的值,</span></span><br><span class="line"><span class="comment">     * 并将该值拆分成单个的词,然后按单词发出新的tuple。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        String sentence = input.getStringByField(<span class="string">"sentence"</span>);</span><br><span class="line">        String[] words = sentence.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">this</span>.collector.emit(<span class="keyword">new</span> Values(word));<span class="comment">//向下一个bolt发射数据</span></span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * plitSentenceBolt类定义一个元组流,每个包含一个字段(“word”)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-编写-WordCountBolt-java"><a href="#2-5-编写-WordCountBolt-java" class="headerlink" title="2.5 编写 WordCountBolt.java"></a>2.5 编写 WordCountBolt.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bolts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.OutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Tuple;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅 split sentence bolt的输出流，实现单词计数，并发送当前计数给下一个bolt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> soul</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputCollector collector;</span><br><span class="line">    <span class="comment">//存储单词和对应的计数</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Long&gt; counts = <span class="keyword">null</span>;<span class="comment">//注：不可序列化对象需在prepare中实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大部分实例变量通常是在prepare()中进行实例化，这个设计模式是由topology的部署方式决定的</span></span><br><span class="line"><span class="comment">     * 因为在部署拓扑时,组件spout和bolt是在网络上发送的序列化的实例变量。</span></span><br><span class="line"><span class="comment">     * 如果spout或bolt有任何non-serializable实例变量在序列化之前被实例化(例如,在构造函数中创建)</span></span><br><span class="line"><span class="comment">     * 会抛出NotSerializableException并且拓扑将无法发布。</span></span><br><span class="line"><span class="comment">     * 本例中因为HashMap 是可序列化的,所以可以安全地在构造函数中实例化。</span></span><br><span class="line"><span class="comment">     * 但是，通常情况下最好是在构造函数中对基本数据类型和可序列化的对象进行复制和实例化</span></span><br><span class="line"><span class="comment">     * 而在prepare()方法中对不可序列化的对象进行实例化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">this</span>.collector = collector;</span><br><span class="line">        <span class="keyword">this</span>.counts = <span class="keyword">new</span> HashMap&lt;String, Long&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在execute()方法中,我们查找的收到的单词的计数(如果不存在，初始化为0)</span></span><br><span class="line"><span class="comment">     * 然后增加计数并存储,发出一个新的词和当前计数组成的二元组。</span></span><br><span class="line"><span class="comment">     * 发射计数作为流允许拓扑的其他bolt订阅和执行额外的处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        String word = input.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        Long count = <span class="keyword">this</span>.counts.get(word);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">            count = <span class="number">0L</span>;<span class="comment">//如果不存在，初始化为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        count++;<span class="comment">//增加计数</span></span><br><span class="line">        <span class="keyword">this</span>.counts.put(word, count);<span class="comment">//存储计数</span></span><br><span class="line">        <span class="keyword">this</span>.collector.emit(<span class="keyword">new</span> Values(word,count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//声明一个输出流，其中tuple包括了单词和对应的计数，向后发射</span></span><br><span class="line">        <span class="comment">//其他bolt可以订阅这个数据流进一步处理</span></span><br><span class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>,<span class="string">"count"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-编写-ReportBolt-java"><a href="#2-6-编写-ReportBolt-java" class="headerlink" title="2.6 编写 ReportBolt.java"></a>2.6 编写 ReportBolt.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bolts;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.OutputCollector;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.TopologyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Tuple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一份报告</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> soul</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportBolt</span> <span class="keyword">extends</span> <span class="title">BaseRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Long&gt; counts = <span class="keyword">null</span>;<span class="comment">//保存单词和对应的计数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context, OutputCollector collector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.counts = <span class="keyword">new</span> HashMap&lt;String, Long&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        String word = input.getStringByField(<span class="string">"word"</span>);</span><br><span class="line">        Long count = input.getLongByField(<span class="string">"count"</span>);</span><br><span class="line">        <span class="keyword">this</span>.counts.put(word, count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实时输出</span></span><br><span class="line">        System.out.println(<span class="string">"结果:"</span>+<span class="keyword">this</span>.counts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//这里是末端bolt，不需要发射数据流，这里无需定义</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cleanup是IBolt接口中定义</span></span><br><span class="line"><span class="comment">     * Storm在终止一个bolt之前会调用这个方法</span></span><br><span class="line"><span class="comment">     * 本例我们利用cleanup()方法在topology关闭时输出最终的计数结果</span></span><br><span class="line"><span class="comment">     * 通常情况下，cleanup()方法用来释放bolt占用的资源，如打开的文件句柄或数据库连接</span></span><br><span class="line"><span class="comment">     * 但是当Storm拓扑在一个集群上运行，IBolt.cleanup()方法不能保证执行（这里是开发模式，生产环境不要这样做）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------- FINAL COUNTS -----------"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        keys.addAll(<span class="keyword">this</span>.counts.keySet());</span><br><span class="line">        Collections.sort(keys);</span><br><span class="line">        <span class="keyword">for</span>(String key : keys)&#123;</span><br><span class="line">            System.out.println(key + <span class="string">" : "</span> + <span class="keyword">this</span>.counts.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-编写-App-java"><a href="#2-7-编写-App-java" class="headerlink" title="2.7 编写 App.java"></a>2.7 编写 App.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.storm.Config;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.LocalCluster;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.TopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.utils.Utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bolts.ReportBolt;</span><br><span class="line"><span class="keyword">import</span> bolts.SplitSentenceBolt;</span><br><span class="line"><span class="keyword">import</span> bolts.WordCountBolt;</span><br><span class="line"><span class="keyword">import</span> spouts.SentenceSpout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现单词计数topology</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SENTENCE_SPOUT_ID = <span class="string">"sentence-spout"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLIT_BOLT_ID = <span class="string">"split-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COUNT_BOLT_ID = <span class="string">"count-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_BOLT_ID = <span class="string">"report-bolt"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPOLOGY_NAME = <span class="string">"word-count-topology"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="comment">//throws Exception</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println( "Hello World!" );</span></span><br><span class="line">        <span class="comment">//实例化spout和bolt</span></span><br><span class="line"></span><br><span class="line">        SentenceSpout spout = <span class="keyword">new</span> SentenceSpout();</span><br><span class="line">        SplitSentenceBolt splitBolt = <span class="keyword">new</span> SplitSentenceBolt();</span><br><span class="line">        WordCountBolt countBolt = <span class="keyword">new</span> WordCountBolt();</span><br><span class="line">        ReportBolt reportBolt = <span class="keyword">new</span> ReportBolt();</span><br><span class="line"></span><br><span class="line">        TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();<span class="comment">//创建了一个TopologyBuilder实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//TopologyBuilder提供流式风格的API来定义topology组件之间的数据流</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//builder.setSpout(SENTENCE_SPOUT_ID, spout);//注册一个sentence spout</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置两个Executeor(线程)，默认一个</span></span><br><span class="line">        builder.setSpout(SENTENCE_SPOUT_ID, spout,<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// SentenceSpout --&gt; SplitSentenceBolt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册一个bolt并订阅sentence发射出的数据流，shuffleGrouping方法告诉Storm要将SentenceSpout发射的tuple随机均匀的分发给SplitSentenceBolt的实例</span></span><br><span class="line">        <span class="comment">//builder.setBolt(SPLIT_BOLT_ID, splitBolt).shuffleGrouping(SENTENCE_SPOUT_ID);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SplitSentenceBolt单词分割器设置4个Task，2个Executeor(线程)</span></span><br><span class="line">        builder.setBolt(SPLIT_BOLT_ID, splitBolt,<span class="number">2</span>).setNumTasks(<span class="number">4</span>).shuffleGrouping(SENTENCE_SPOUT_ID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SplitSentenceBolt --&gt; WordCountBolt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//fieldsGrouping将含有特定数据的tuple路由到特殊的bolt实例中</span></span><br><span class="line">        <span class="comment">//这里fieldsGrouping()方法保证所有“word”字段相同的tuuple会被路由到同一个WordCountBolt实例中</span></span><br><span class="line">        <span class="comment">//builder.setBolt(COUNT_BOLT_ID, countBolt).fieldsGrouping( SPLIT_BOLT_ID, new Fields("word"));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//WordCountBolt单词计数器设置4个Executeor(线程)</span></span><br><span class="line">        builder.setBolt(COUNT_BOLT_ID, countBolt,<span class="number">4</span>).fieldsGrouping( SPLIT_BOLT_ID, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// WordCountBolt --&gt; ReportBolt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//globalGrouping是把WordCountBolt发射的所有tuple路由到唯一的ReportBolt</span></span><br><span class="line">        builder.setBolt(REPORT_BOLT_ID, reportBolt).globalGrouping(COUNT_BOLT_ID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();<span class="comment">//Config类是一个HashMap&lt;String,Object&gt;的子类，用来配置topology运行时的行为</span></span><br><span class="line">        <span class="comment">//设置worker数量</span></span><br><span class="line">        <span class="comment">//config.setNumWorkers(2);</span></span><br><span class="line">        LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//本地提交</span></span><br><span class="line">        cluster.submitTopology(TOPOLOGY_NAME, config, builder.createTopology());</span><br><span class="line"></span><br><span class="line">        Utils.sleep(<span class="number">10000</span>);</span><br><span class="line">        cluster.killTopology(TOPOLOGY_NAME);</span><br><span class="line">        Utils.sleep(<span class="number">1000</span>);</span><br><span class="line">        cluster.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该项目Git地址：<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:tclm/storm-book-examples-ch02-getting_started-8e42636.git</p><hr><h3 id="3-常用API"><a href="#3-常用API" class="headerlink" title="3. 常用API"></a>3. 常用API</h3><h5 id="3-1-Spout"><a href="#3-1-Spout" class="headerlink" title="3.1 Spout"></a>3.1 Spout</h5><p>通常情况下，继承 org.apache.storm.topology.base.BaseRichSpout 重写以下三个方法即可实现一个 Spout。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* open()方法中是ISpout接口中定义，在Spout组件初始化时被调用。</span></span><br><span class="line"><span class="comment">* open()接受三个参数:一个包含Storm配置的Map;</span></span><br><span class="line"><span class="comment">*                    一个TopologyContext对象;</span></span><br><span class="line"><span class="comment">*                    提供了topology中组件的信息,SpoutOutputCollector对象提供发射tuple的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                     </span><br><span class="line">open(Map conf, TopologyContext context, SpoutOutputCollector collector)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nextTuple()方法是任何Spout实现的核心。</span></span><br><span class="line"><span class="comment"> * Storm调用这个方法，向输出的collector发出tuple。</span></span><br><span class="line"><span class="comment"> * 在这里,我们只是发出当前索引的句子，并增加该索引准备发射下一个句子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">nextTuple()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * declareOutputFields是在IComponent接口中定义的，所有Storm的组件（spout和bolt）都必须实现这个接口</span></span><br><span class="line"><span class="comment"> * 用于告诉Storm流组件将会发出那些数据流，每个流的tuple将包含的字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">declareOutputFields(OutputFieldsDeclarer declarer)</span><br></pre></td></tr></table></figure><h5 id="3-2-Bolt"><a href="#3-2-Bolt" class="headerlink" title="3.2 Bolt"></a>3.2 Bolt</h5><p>通常情况下，继承 org.apache.storm.topology.base.BaseRichBolt 重写以下三个方法即可实现一个 Bolt。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare()方法类似于ISpout 的open()方法。</span></span><br><span class="line"><span class="comment"> * 这个方法在blot初始化时调用，可以用来准备bolt用到的资源,比如数据库连接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">prepare(Map stormConf, TopologyContext context, OutputCollector collector)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每一个Bolt核心功能是在接口IBolt定义的execute()方法</span></span><br><span class="line"><span class="comment"> * 每次Bolt从流接收一个订阅的tuple，都会调用这个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">execute(Tuple input)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * declareOutputFields是在IComponent接口中定义的，所有Storm的组件（spout和bolt）都必须实现这个接口</span></span><br><span class="line"><span class="comment"> * 用于告诉Storm流组件将会发出那些数据流，每个流的tuple将包含的字段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">declareOutputFields(OutputFieldsDeclarer declarer)</span><br></pre></td></tr></table></figure><h5 id="3-3-TopologyBuilder"><a href="#3-3-TopologyBuilder" class="headerlink" title="3.3 TopologyBuilder"></a>3.3 TopologyBuilder</h5><p>TopologyBuilder 用于创建一个 Topology（拓扑结构），Topology 实际就是 spout 和 bolt之间的关系定义.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Topology定义一个新的Spout</span></span><br><span class="line"><span class="comment"> *  id 用来在需要消费其产生的Tuple的Bolt订阅使用</span></span><br><span class="line"><span class="comment"> * parallelism_hint 定义executor的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SpoutDeclarer <span class="title">setSpout</span><span class="params">(String id, IRichSpout spout, Number parallelism_hint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 在Topology定义一个新的Bolt</span></span></span><br><span class="line"><span class="function"><span class="comment"> *  id 用来在需要消费其产生的Tuple的Bolt订阅使用</span></span></span><br><span class="line"><span class="function"><span class="comment"> * parallelism_hint 定义executor的数量</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">BoltDeclarer <span class="title">setBolt</span><span class="params">(String id, IRichBolt bolt, Number parallelism_hint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 所有的xxxGrouping 都是用来订阅Tuple的消息</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 不同的 Grouping 执行方式不同，Storm默认提供七种不同的流分组策略，具体差异见 5. 流分组策略</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">BoltDeclarer.<span class="title">shuffleGrouping</span><span class="params">(String componentId)</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4. 基本概念"></a>4. 基本概念</h3><p>熟悉了 Storm Hello World 和 常用的 API,现在了解一下 Storm 的一些基本概念。</p><h4 id="4-1-spout"><a href="#4-1-spout" class="headerlink" title="4.1 spout"></a>4.1 spout</h4><p>数据源（Spout）是拓扑中数据流的来源。一般 Spout 会从一个外部的数据源读取元组然后将他们发送到拓扑中。根据需求的不同，Spout 既可以定义为<strong>可靠</strong>的数据源，也可以定义为<strong>不可靠</strong>的数据源。一个可靠的 Spout 能够在它发送的元组处理失败时重新发送该元组，以确保所有的元组都能得到正确的处理；相对应的，不可靠的 Spout 就不会在元组发送之后对元组进行任何其他的处理。</p><p>一个 Spout 可以发送多个数据流。为了实现这个功能，可以先通过 OutputFieldsDeclarer 的 declareStream 方法来声明定义不同的数据流，然后在发送数据时在 SpoutOutputCollector 的 emit 方法中将数据流 id 作为参数来实现数据发送的功能。</p><p>Spout 中的关键方法是 nextTuple。顾名思义，nextTuple 要么会向拓扑中发送一个新的元组，要么会在没有可发送的元组时直接返回。需要特别注意的是，由于 Storm 是在同一个线程中调用所有的 Spout 方法，nextTuple 不能被 Spout 的任何其他功能方法所阻塞，否则会直接导致数据流的中断（关于这一点，阿里的 JStorm 修改了 Spout 的模型，使用不同的线程来处理消息的发送，这种做法有利有弊，好处在于可以更加灵活地实现 Spout，坏处在于系统的调度模型更加复杂，如何取舍还是要看具体的需求场景吧——译者注）。</p><p>Spout 中另外两个关键方法是 ack 和 fail，他们分别用于在 Storm 检测到一个发送过的元组已经被成功处理或处理失败后的进一步处理。注意，ack 和 fail 方法仅仅对上述“可靠的” Spout 有效。</p><h4 id="4-2-bolt"><a href="#4-2-bolt" class="headerlink" title="4.2 bolt"></a>4.2 bolt</h4><p>拓扑中所有的数据处理均是由 Bolt 完成的。通过数据过滤（filtering）、函数处理（functions）、聚合（aggregations）、联结（joins）、数据库交互等功能，Bolt 几乎能够完成任何一种数据处理需求。</p><p>一个 Bolt 可以实现简单的数据流转换，而更复杂的数据流变换通常需要使用多个 Bolt 并通过多个步骤完成。例如，将一个微博数据流转换成一个趋势图像的数据流至少包含两个步骤：其中一个 Bolt 用于对每个图片的微博转发进行滚动计数，另一个或多个 Bolt 将数据流输出为“转发最多的图片”结果（相对于使用2个Bolt，如果使用3个 Bolt 你可以让这种转换具有更好的可扩展性）。</p><p>与 Spout 相同，Bolt 也可以输出多个数据流。为了实现这个功能，可以先通过 OutputFieldsDeclarer 的 declareStream 方法来声明定义不同的数据流，然后在发送数据时在 OutputCollector 的 emit 方法中将数据流 id 作为参数来实现数据发送的功能。</p><p>在定义 Bolt 的输入数据流时，你需要从其他的 Storm 组件中订阅指定的数据流。如果你需要从其他所有的组件中订阅数据流，你就必须要在定义 Bolt 时分别注册每一个组件。对于声明为默认 id（即上文中提到的“default”——译者注）的数据流，InputDeclarer支持订阅此类数据流的语法糖。也就是说，如果需要订阅来自组件“1”的数据流，declarer.shuffleGrouping(“1”) 与 declarer.shuffleGrouping(“1”, DEFAULT_STREAM_ID) 两种声明方式是等价的。</p><p>Bolt 的关键方法是 execute 方法。execute 方法负责接收一个元组作为输入，并且使用 OutputCollector 对象发送新的元组。如果有消息可靠性保障的需求，Bolt 必须为它所处理的每个元组调用 OutputCollector 的 ack 方法，以便 Storm 能够了解元组是否处理完成（并且最终决定是否可以响应最初的 Spout 输出元组树）。一般情况下，对于每个输入元组，在处理之后可以根据需要选择不发送还是发送多个新元组，然后再响应（ack）输入元组。</p><h4 id="4-3-tuple"><a href="#4-3-tuple" class="headerlink" title="4.3 tuple"></a>4.3 tuple</h4><p>元组是 Storm 中消息传输的基本单元，是一个命名的值列表（List）。<br>元组支持所有基本类型、字符串、字节数组作为字段的值，只要实现类型的序列化接口就可以使用该类型的对象。<br>元组本来应该是一个 Key-value 的 Map ，但是由于组件之间传递的元组的字段名称已经事先定义好，所以只需要按照顺序，将值填入 List 即可。</p><h4 id="4-4-Stream"><a href="#4-4-Stream" class="headerlink" title="4.4 Stream"></a>4.4 Stream</h4><p>数据流（Streams）是 Storm 中最核心的抽象概念。一个数据流指的是在分布式环境中并行创建、处理的一组元组（tuple）的无界序列。数据流可以由一种能够表述数据流中元组的域（fields）的模式来定义。在默认情况下，元组（tuple）包含有整型（Integer）数字、长整型（Long）数字、短整型（Short）数字、字节（Byte）、双精度浮点数（Double）、单精度浮点数（Float）、布尔值以及字节数组等基本类型对象。当然，你也可以通过定义可序列化的对象来实现自定义的元组类型。</p><p>在声明数据流的时候需要给数据流定义一个有效的 id。不过，由于在实际应用中使用最多的还是单一数据流的 Spout 与 Bolt，这种场景下不需要使用 id 来区分数据流，因此可以直接使用 OutputFieldsDeclarer来定义“无 id”的数据流。实际上，系统默认会给这种数据流定义一个名为“default”的 id。</p><h4 id="4-5-topology"><a href="#4-5-topology" class="headerlink" title="4.5 topology"></a>4.5 topology</h4><p>拓扑可以理解成由一系列通过数据流（Stream Grouping）相互关联的 Spout 和 Bolt 组成的的拓扑结构。Spout 和 Bolt 称为拓扑的组件（Component）。<br>Storm 的拓扑是对实时计算应用逻辑的封装，它的作用与 MapReduce 的任务（Job）很相似，区别在于 MapReduce 的一个 Job 在得到结果之后总会结束，而拓扑会一直在集群中运行，直到你手动去终止它。</p><h4 id="4-6-worker"><a href="#4-6-worker" class="headerlink" title="4.6 worker"></a>4.6 worker</h4><p>拓扑是在一个或多个工作进程（worker processes）中运行的。每个工作进程都是一个实际的 JVM 进程，并且执行拓扑的一个子集。</p><h4 id="4-7-executor"><a href="#4-7-executor" class="headerlink" title="4.7 executor"></a>4.7 executor</h4><p>executor即是执行任务的线程<br>一台服务器可以部署多个 worker 进程；每个 worker 进程中可以有多个 Executor（对应一个线程）；每个 Executor 中执行一个或者多个 task。<br>Executor 的个数，可以通过 setSpout 或者 SetBolt 中的并行度参数进行调整。</p><h4 id="4-8-task"><a href="#4-8-task" class="headerlink" title="4.8 task"></a>4.8 task</h4><p>task 是实际执行数据处理的最小工作单元,被 executor 所执行。<br>Storm 集群中，可以通过设置拓扑中每个 Spout 或 Bolt 的任务数（setNumTasks()），调整他们执行的任务数。</p><hr><hr><h3 id="5-流分组策略"><a href="#5-流分组策略" class="headerlink" title="5. 流分组策略"></a>5. 流分组策略</h3><p>根据选择的分组策略不同，task的执行方式有差异，Storm默认提供下面8种分组策略，也支持自定分组策略（customGrouping），关于自定义分组，在此不做讨论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.随机分组、轮询、平均分配,随机派发stream里面的tuple，保证每个bolt task接收到的tuple数目大致相同。</span></span><br><span class="line">topologyBuilder.setBolt(<span class="string">"MYBOLTS1"</span>, myBolts,<span class="number">4</span>).shuffleGrouping(<span class="string">"MYSPOUT"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.按字段分组，比如，按"user-id"这个字段来分组，那么具有同样"user-id"的 tuple 会被分到相同的Bolt里的一个task。</span></span><br><span class="line">topologyBuilder.setBolt(<span class="string">"MYBOLTS2"</span>, myBolts,<span class="number">2</span>).fieldsGrouping(<span class="string">"MYSPOUT"</span>,<span class="keyword">new</span> Fields(<span class="string">"number"</span>)).setNumTasks(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.广播发送，对于每一个tuple，所有的bolts都会收到</span></span><br><span class="line">topologyBuilder.setBolt(<span class="string">"MYBOLTS3"</span>, myBolts,<span class="number">1</span>).allGrouping(<span class="string">"MYSPOUT"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.Stream中的所有的tuple都会发送给同一个bolt任务处理，所有的tuple将会发送给拥有最小task_id的bolt任务处理</span></span><br><span class="line">topologyBuilder.setBolt(<span class="string">"MYBOLTS4"</span>, myBolts,<span class="number">4</span>).globalGrouping(<span class="string">"MYSPOUT"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.不分组，这个分组的意思是说stream不关心到底怎样分组。目前这种分组和Shuffle grouping是一样的效果。 有一点不同的是storm会把使用none grouping的这个bolt放到这个bolt的订阅者同一个线程里面去执行（未来Storm如果可能的话会这样设计）。  </span></span><br><span class="line">topologyBuilder.setBolt(<span class="string">"MYBOLTS5"</span>, myBolts,<span class="number">4</span>).noneGrouping(<span class="string">"MYSPOUT"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.指向型分组， 这是一种比较特别的分组方法，用这种分组意味着消息（tuple）的发送者指定由消息接收者的哪个task处理这个消息。只有被声明为 Direct Stream 的消息流可以声明这种分组方法。而且这种消息tuple必须使用 emitDirect 方法来发射。消息处理者可以通过 TopologyContext 来获取处理它的消息的task的id (OutputCollector.emit方法也会返回task的id)   </span></span><br><span class="line"><span class="comment">//topologyBuilder.setBolt("MYBOLTS6", myBolts,4).directGrouping("MYSPOUT");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.本地或随机分组。如果目标bolt有一个或者多个task与源bolt的task在同一个工作进程中，tuple将会被随机发送给这些同进程中的tasks。否则，和普通的Shuffle Grouping行为一致 </span></span><br><span class="line">topologyBuilder.setBolt(<span class="string">"MYBOLTS7"</span>, myBolts,<span class="number">4</span>).localOrShuffleGrouping(<span class="string">"MYSPOUT"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.这种方式与按字段分组很相似，根据定义的域来对数据流进行分组，不同的是，这种方式会考虑下游 Bolt 数据处理的均衡性问题，在输入数据源关键字不平衡时会有更好的性能</span></span><br><span class="line">topologyBuilder.setBolt(<span class="string">"MYBOLTS8"</span>, myBolts,<span class="number">4</span>).partialKeyGrouping((<span class="string">"MYSPOUT"</span>), <span class="keyword">new</span> Fields(<span class="string">"number"</span>));</span><br></pre></td></tr></table></figure><p>有关流分组策略的执行效果，可参考下面这个项目<br><a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:tclm/HelloStorm.git<br><strong>Run.java</strong></p><hr><h3 id="6-并行度"><a href="#6-并行度" class="headerlink" title="6. 并行度"></a>6. 并行度</h3><p>并行度可以理解的同时执行的进程、线程、任务数量</p><p><img src="https://s1.ax1x.com/2018/05/10/C0ps0O.png" alt="fig-parallelism-1.png"></p><p>在 Worker 中运行的是拓扑的一个子集。一个 worker 进程是从属于某一个特定的拓扑的，在 worker 进程中会运行一个或者多个与拓扑中的组件相关联的 executor。一个运行中的拓扑就是由这些运行于 Storm 集群中的很多机器上的进程组成的。</p><p>一个 executor 是由 worker 进程生成的一个线程。在 executor 中可能会有一个或者多个 task，这些 task 都是为同一个组件（spout 或者 bolt）服务的。</p><p>task 是实际执行数据处理的最小工作单元（注意，task 并不是线程） —— 在你的代码中实现的每个 spout 或者 bolt 都会在集群中运行很多个 task。在拓扑的整个生命周期中每个组件的 task 数量都是保持不变的，不过每个组件的 executor 数量却是有可能会随着时间变化。在默认情况下 task 的数量是和 executor 的数量一样的，也就是说，默认情况下 Storm 会在每个线程上运行一个 task。</p><p><strong>并行度的设置</strong></p><p>其中进程（Worker）数通过 Config.setNumWorkers(Number）设置。</p><p>线程（Executors）数量通过下面两个方法的parallelism_hint参数设置。<br>TopologyBuilder.setSpout()<br>TopologyBuilder.setBolt()</p><p>任务（task）数量通过下面两个方法设置<br>SpoutDeclarer.setNumTasks(Number)<br>BoltDeclarer.setNumTasks(Number)</p><p>效果上 Worker &gt; Executors &gt; Task</p><hr><h3 id="7-Acker机制"><a href="#7-Acker机制" class="headerlink" title="7. Acker机制"></a>7. Acker机制</h3><p>Storm通过Acker机制保证了<strong>可靠性</strong>.</p><p>要实现Ack机制，需要进行一下操作。<br>1.spout 需重写 ack(Object msgId) 和 fail（Object msgId）两个方法<br>2.spout发射tuple的时候指定messageId.<br>3.spout需对自己发射tuple进行缓存<br>4.spout根据messageId对于ack的tuple则从缓存队列中删除，对于fail的tuple可以选择重发。<br>5.通过Config.setNumAckers(conf, ackerParal) 设置 acker数至少大于0；</p><p>有关ACK机制的执行效果，可参考下面这个项目<br><a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:tclm/HelloStorm.git<br><strong>RunAck.java</strong></p><hr><p>###8. 参考资料</p><p>[1].<a href="http://ifeve.com/apache-storm/" target="_blank" rel="noopener">Apache Storm 官方文档中文版</a><br>[2].<a href="https://blog.csdn.net/uisoul/article/details/77989927" target="_blank" rel="noopener">最详细的Storm入门教程</a><br>[3].<a href="http://www.cnblogs.com/intsmaze/p/5918087.html" target="_blank" rel="noopener">Storm的ack机制在项目应用中的坑</a></p><hr><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Startop1=>operation: SentenceSpout（获取并发射句子）op2=>operation: SplitSentenceBolt（拆分并发送单词）op3=>operation: WordCountBolt（统计单词并发送结果）op4=>operation: ReportBolt （输出结果）e=>endst->op1->op2->op3->op4->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开箱 </tag>
            
            <tag> Storm </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
